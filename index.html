<!DOCTYPE html>
<html lang="pt-BR">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Jogo da MemÃ³ria ðŸ‘¶</title>
  <meta name="description"
    content="Jogo da memÃ³ria do casal: revele o sexo do bebÃª apenas na Ãºltima dupla encontrada." />
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <!-- canvas-confetti CDN (opcional; temos fallback nativo) -->
  <script defer src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/dist/confetti.browser.min.js"></script>

  <style>
    :root {
      --bg: #0f1220;
      --card: #14172b;
      --cardBack: #0f1325;
      --accent: #ffd166;
      --ok: #4ade80;
      --bad: #f87171;
      --radius: 18px;
      --shadow: 0 8px 24px rgba(0, 0, 0, .25);
      --flip-dur: 260ms;
      --easing: cubic-bezier(.2, .8, .2, 1);
      --text: #e9edf7;
      --muted: #94a3b8;
      --grid-gap: clamp(8px, 2.2vw, 14px);
      --title-size: clamp(1.2rem, 2.6vw + 1rem, 2rem);
      --hud-size: clamp(.85rem, 1.2vw + .8rem, 1rem);
    }

    * {
      box-sizing: border-box
    }

    html,
    body {
      height: 100%
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial;
      background: #ffffff;
      color: var(--text);
      -webkit-font-smoothing: antialiased;
      text-rendering: optimizeLegibility;
      overflow-x: hidden;
      transition: background .4s var(--easing);
    }

    header {
      position: sticky;
      top: 0;
      z-index: 3;
      backdrop-filter: blur(8px);
      background: #fff;
    }

    .bar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: clamp(10px, 2vh, 16px) clamp(14px, 4vw, 24px);
    }

    .title {
      font-weight: 700;
      letter-spacing: .3px;
      font-size: var(--title-size);
      color: black;
    }

    .hud {
      display: flex;
      gap: 12px;
      align-items: center;
      font-size: var(--hud-size);
      color: black
    }

    .hud strong {
      color: black
    }

    .btn {
      appearance: none;
      border: 0;
      padding: .6rem .9rem;
      border-radius: 12px;
      background: #606060;
      color: #e6f0ff;
      font-weight: 650;
      box-shadow: var(--shadow);
      transition: transform .08s var(--easing), filter .2s var(--easing), opacity .2s var(--easing);
      touch-action: manipulation;
    }

    .btn:active {
      transform: translateY(1px) scale(.98)
    }

    .btn.secondary {
      background: #232842;
      color: #b8c4e6
    }

    main {
      padding: clamp(10px, 2.5vh, 20px) clamp(12px, 4vw, 24px) max(env(safe-area-inset-bottom, 16px), 16px);
      display: grid;
      gap: clamp(14px, 2.5vh, 18px);
      transition: filter .3s var(--easing), opacity .3s var(--easing);
    }

    body.reveal-mode main {
      filter: blur(3px);
      opacity: .2;
      pointer-events: none;
    }

    .grid {
      --cols: 3;
      display: grid;
      grid-template-columns: repeat(var(--cols), 1fr);
      gap: var(--grid-gap);
      margin: 0 auto;
      width: 100%;
      max-width: min(540px, 96vw);
    }

    @media (min-width: 420px) {
      .grid {
        --cols: 4
      }

      .reveal-text {
        width: min(420px, 96vw);
      }
    }

    @media (min-width: 720px) {
      .grid {
        --cols: 4;
        max-width: 640px
      }
    }

    .card {
      position: relative;
      width: 100%;
      aspect-ratio: 3 / 4;
      perspective: 1000px;
      user-select: none;
    }

    .card button {
      all: unset;
      display: block;
      position: absolute;
      inset: 0;
      cursor: pointer;
      border-radius: var(--radius);
      outline: none;
    }

    .card .inner {
      position: absolute;
      inset: 0;
      transform-style: preserve-3d;
      transition: transform var(--flip-dur) var(--easing);
      will-change: transform;
      transform: translateZ(0);
    }

    .card.flipped .inner {
      transform: rotateY(180deg);
    }

    .face {
      position: absolute;
      inset: 0;
      backface-visibility: hidden;
      border-radius: var(--radius);
      overflow: hidden;
      box-shadow: var(--shadow);
      border: 1px solid rgba(255, 255, 255, .06);
    }

    .front {
      transform: rotateY(180deg);
    }

    .front img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
      opacity: 0;
      transition: opacity .25s var(--easing);
    }

    .front img.loaded {
      opacity: 1
    }

    .back {
      background:
        radial-gradient(120px 120px at 20% 15%, #1f284c 0%, transparent 60%),
        radial-gradient(150px 100px at 80% 85%, #222b56 0%, transparent 60%),
        var(--cardBack);
      display: grid;
      place-items: center;
      position: relative;
      isolation: isolate;
      height: 100%;
    }

    .back::before {
      content: "";
      position: absolute;
      inset: 0;
      background:
        linear-gradient(135deg, rgba(255, 255, 255, .06) 25%, transparent 25%) -8px 0/16px 16px,
        linear-gradient(225deg, rgba(255, 255, 255, .06) 25%, transparent 25%) -8px 0/16px 16px,
        linear-gradient(315deg, rgba(255, 255, 255, .06) 25%, transparent 25%) 0px 0/16px 16px,
        linear-gradient(45deg, rgba(255, 255, 255, .06) 25%, transparent 25%) 0px 0/16px 16px;
      opacity: .4;
      mix-blend-mode: overlay;
    }

    .qmark {
      font-size: clamp(1.6rem, 6vw, 2.4rem);
      font-weight: 800;
      color: #cbd5e1;
      text-shadow: 0 2px 8px rgba(0, 0, 0, .35);
      transform: translateZ(0);
    }

    .skeleton {
      position: absolute;
      inset: 0;
      background:
        linear-gradient(110deg, rgba(255, 255, 255, .05) 25%, rgba(255, 255, 255, .12) 35%, rgba(255, 255, 255, .05) 45%) 0 0/200% 100%,
        #1a2140;
      animation: shine 1.1s linear infinite;
      z-index: 0;
    }

    @keyframes shine {
      to {
        background-position: -200% 0
      }
    }

    /* Overlays (suspense e revelaÃ§Ã£o) */
    .overlay {
      position: fixed;
      inset: 0;
      display: none;
      place-items: center;
      padding: clamp(16px, 4vw, 28px);
      color: #0b1220;
      z-index: 4;
    }

    .overlay.show {
      display: grid;
    }

    /* Suspense */
    #suspense {
      background: rgba(0, 0, 0, .5);
      color: #fff;
      text-align: center;
      backdrop-filter: blur(6px);
    }

    .countdown {
      font-size: clamp(2.2rem, 10vw, 4rem);
      font-weight: 900;
      letter-spacing: .5px;
      margin-top: .25rem;
    }

    .suspense-title {
      font-size: clamp(1.2rem, 5vw, 2rem);
      font-weight: 800;
    }

    /* RevelaÃ§Ã£o */
    .reveal-card {
      border-radius: 24px;
      padding: clamp(18px, 4vw, 32px);
      background: rgba(255, 255, 255, .86);
      backdrop-filter: blur(10px);
      box-shadow: 0 16px 50px rgba(0, 0, 0, .25);
      text-align: center;
      animation: pop .6s var(--easing);
    }

    @keyframes pop {
      from {
        transform: scale(.9);
        opacity: 0
      }
    }

    .reveal-title {
      font-size: clamp(1.8rem, 6vw, 3rem);
      font-weight: 900;
      letter-spacing: .6px;
      animation: bounce 1.2s var(--easing) infinite alternate;
      color: #ff7fbf;
    }

    @keyframes bounce {
      from {
        transform: translateY(0)
      }

      to {
        transform: translateY(-6px)
      }
    }

    .baby-name {
      margin-top: .25rem;
      font-weight: 800;
      font-size: clamp(1.3rem, 4.8vw, 2.2rem);
    }

    .reveal-text {
      color: #0e1528;
      line-height: 1.4;
      text-wrap: pretty;
      font-size: clamp(.95rem, 2.6vw, 1.05rem);
      white-space: pre-line;
    }

    .reveal-welcome {
      margin: .6rem 0 1rem;
      font-weight: 800;
    }

    .screen-reader {
      position: absolute;
      left: -9999px;
      top: auto;
      width: 1px;
      height: 1px;
      overflow: hidden;
    }
  </style>
</head>

<body>
  <header>
    <div class="bar">
      <div class="title">Jogo da MemÃ³ria</div>
      <div class="hud" aria-live="polite">
        <div>Jogadas: <strong id="moves">0</strong></div>
        <div>Tempo: <strong id="time">00:00</strong></div>
      </div>
      <button id="restartTop" class="btn secondary" type="button" aria-label="Reiniciar o jogo">Reiniciar</button>
    </div>
  </header>

  <main>
    <section aria-label="Tabuleiro do jogo" class="grid" id="grid" role="grid"></section>
  </main>

  <!-- Overlay de SUSPENSE -->
  <div id="suspense" class="overlay" aria-hidden="true">
    <div class="reveal-card" style="background:rgba(0,0,0,.35); color:#fff;">
      <div class="suspense-title">Segura o coraÃ§Ã£o... ðŸ’–</div>
      <div>RevelaÃ§Ã£o em</div>
      <div id="countdown" class="countdown">5</div>
    </div>
  </div>

  <!-- Overlay de REVELAÃ‡ÃƒO -->
  <div id="overlay" class="overlay" aria-modal="true" role="dialog" aria-label="RevelaÃ§Ã£o do sexo do bebÃª">
    <div class="reveal-card">
      <h2 id="revealTitle" class="reveal-title">Ã‰ MENINA!</h2>
      <div id="babyName" class="baby-name">SejÃ¡ bem vinda, TÃ¡lia!!!ðŸŽ€</div>
      <p class="reveal-text" id="revealText"></p>
      <p class="reveal-welcome" id="revealWelcome"></p>
      <button id="playAgain" class="btn" type="button">Jogar de novo</button>
    </div>
  </div>

  <!-- Canvas de efeitos (no topo de tudo) -->
  <canvas id="fxCanvas"
    style="position:fixed; inset:0; width:100%; height:100%; pointer-events:none; z-index:9999;"></canvas>

  <!-- Aria-live invisÃ­vel -->
  <div id="ariaLive" class="screen-reader" aria-live="polite"></div>

  <script>
    window.addEventListener('DOMContentLoaded', () => {
      // ===========================
      // CONFIGURAÃ‡ÃƒO DO JOGO
      // ===========================
      const GAME_CONFIG = {
        pairs: 6,
        revealGender: "girl", // "girl" | "boy"
        imagesPath: "./public/img/casal/",
        girlColor: "#ffc0e0",
        boyColor: "#8ec5ff"
      };

      const REVEAL_MESSAGE = `A famÃ­lia aumentou e um novo amor surgiu, o primeiro olhar, a primeira palavra, os primeiros passos estÃ£o prestes a acontecer e muitas coisas novas ainda virÃ£o nessa longa caminhada... Deus vai guiar cada passo e vai abenÃ§oar cada nova descoberta! A MamÃ£e e o Papai, felizes, anunciam para toda a famÃ­lia, a sua chegada!`;

      // ===========================
      // ESTADO
      // ===========================
      let state = {
        deck: [],
        firstCard: null,
        secondCard: null,
        lockBoard: false,
        matchedPairs: 0,
        moves: 0,
        startedAt: null,
        timerId: null,
        remainingPairsForReveal: () => (GAME_CONFIG.pairs - state.matchedPairs)
      };

      // DOM refs
      const grid = document.getElementById('grid');
      const movesA = document.getElementById('moves');
      const timeA = document.getElementById('time');
      const restartTop = document.getElementById('restartTop');

      const suspenseLayer = document.getElementById('suspense');
      const countdownEl = document.getElementById('countdown');

      const overlay = document.getElementById('overlay');
      const revealTitle = document.getElementById('revealTitle');
      const babyName = document.getElementById('babyName');
      const revealText = document.getElementById('revealText');
      const revealWelcome = document.getElementById('revealWelcome');
      const playAgain = document.getElementById('playAgain');
      const ariaLive = document.getElementById('ariaLive');
      const fxCanvas = document.getElementById('fxCanvas');

      // ===========================
      // CONFETTI: FALLBACK NATIVO
      // ===========================
      class NativeConfettiEngine {
        constructor(canvas) {
          this.canvas = canvas;
          this.ctx = canvas.getContext('2d');
          this.dpr = window.devicePixelRatio || 1;
          this.particles = [];
          this.running = false;
          this.last = performance.now();
          this.resize();
        }
        resize() {
          const w = Math.floor(window.innerWidth * this.dpr);
          const h = Math.floor(window.innerHeight * this.dpr);
          if (this.canvas.width !== w || this.canvas.height !== h) {
            this.canvas.width = w; this.canvas.height = h;
          }
        }
        spawnBurst(opts) {
          const {
            particleCount = 40, startVelocity = 35, spread = 360,
            origin = { x: Math.random(), y: Math.random() * 0.4 },
            colors = ["#ffffff", "#ffd166", "#9b5de5", "#00bbf9"],
            scalar = 1
          } = opts || {};
          const angleBase = (opts.angle ?? 90) * Math.PI / 180;
          for (let i = 0; i < particleCount; i++) {
            const t = (Math.random() - 0.5) * (spread * Math.PI / 180);
            const a = angleBase + t;
            const sp = startVelocity * (0.5 + Math.random() * 0.8);
            const sx = (origin.x * this.canvas.width);
            const sy = (origin.y * this.canvas.height);
            this.particles.push({
              x: sx, y: sy,
              vx: Math.cos(a) * sp,
              vy: Math.sin(a) * sp,
              g: 0.25 * this.dpr,
              life: 60 + Math.random() * 40,
              size: (3 + Math.random() * 4) * scalar * this.dpr,
              color: colors[Math.floor(Math.random() * colors.length)],
              rot: Math.random() * Math.PI,
              vr: (Math.random() - 0.5) * 0.2
            });
          }
          if (!this.running) this.loop();
        }
        loop() {
          this.running = true;
          const now = performance.now();
          const dt = Math.min(32, now - this.last) / 16.67; // ~frames
          this.last = now;

          const { ctx, canvas } = this;
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          for (let i = this.particles.length - 1; i >= 0; i--) {
            const p = this.particles[i];
            p.vy += p.g * dt;
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.rot += p.vr * dt;
            p.life -= dt;

            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.rotate(p.rot);
            ctx.fillStyle = p.color;
            ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size * 0.7);
            ctx.restore();

            if (p.life <= 0 || p.y > canvas.height + 40 * this.dpr) {
              this.particles.splice(i, 1);
            }
          }

          if (this.particles.length) {
            requestAnimationFrame(() => this.loop());
          } else {
            this.running = false;
          }
        }
      }

      // cannon da CDN (se disponÃ­vel) + engine nativa (fallback)
      function makeCannon() {
        if (!window.confetti) return null;
        try { return window.confetti.create(fxCanvas, { resize: true }); }
        catch { return null; }
      }
      let cannon = makeCannon();
      const nativeEngine = new NativeConfettiEngine(fxCanvas);

      // Recria cannon quando a CDN carregar
      const confettiScript = document.querySelector('script[src*="canvas-confetti"]');
      if (confettiScript) {
        confettiScript.addEventListener('load', () => { if (!cannon) cannon = makeCannon(); });
      }

      // Disparo seguro: usa CDN se houver; senÃ£o, fallback nativo
      function fire(opts) {
        if (cannon) { cannon(opts); return; }
        // adaptar opÃ§Ãµes para nosso engine
        nativeEngine.spawnBurst({
          particleCount: opts?.particleCount ?? 40,
          startVelocity: opts?.startVelocity ?? 35,
          spread: opts?.spread ?? 360,
          angle: opts?.angle ?? 90,
          origin: opts?.origin ?? { x: Math.random(), y: Math.random() * 0.4 },
          colors: opts?.colors ?? ["#ffffff", "#ffd166", "#9b5de5", "#00bbf9"],
          scalar: opts?.scalar ?? 1
        });
      }

      // resize canvas + engine
      function sizeCanvas() {
        nativeEngine.resize();
      }
      sizeCanvas();
      window.addEventListener('resize', () => { requestAnimationFrame(sizeCanvas); }, { passive: true });

      // ===========================
      // IMAGENS / PRELOAD
      // ===========================
      const upTo = Math.min(Math.max(GAME_CONFIG.pairs, 3), 6);
      const imageList = Array.from({ length: upTo }, (_, i) => `${GAME_CONFIG.imagesPath}casal-${i + 1}.png`);

      function preload(src) {
        return new Promise((res, rej) => {
          const img = new Image();
          img.onload = () => res(img);
          img.onerror = rej;
          img.src = src;
        });
      }

      async function preloadAll() {
        try {
          const all = [...imageList].map(preload);
          await Promise.all(all);
        } catch (e) {
          console.warn("Falha ao prÃ©-carregar alguma imagem:", e);
        }
      }

      // ===========================
      // UTILITÃRIOS
      // ===========================
      function shuffle(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
      }
      function formatTime(ms) {
        const s = Math.floor(ms / 1000);
        const mm = String(Math.floor(s / 60)).padStart(2, '0');
        const ss = String(s % 60).padStart(2, '0');
        return `${mm}:${ss}`;
      }
      function vibrate(pattern) { if (navigator.vibrate) navigator.vibrate(pattern); }
      function speak(msg) { ariaLive.textContent = msg; }

      // ===========================
      // TIMER / HUD
      // ===========================
      function startTimer() {
        if (state.timerId) clearInterval(state.timerId);
        state.startedAt = performance.now();
        state.timerId = setInterval(() => {
          const elapsed = performance.now() - state.startedAt;
          const t = formatTime(elapsed);
          timeA.textContent = t;
        }, 250);
      }
      function stopTimer() { if (state.timerId) { clearInterval(state.timerId); state.timerId = null; } }
      function setMoves(n) { state.moves = n; movesA.textContent = n; }

      // ===========================
      // DECK / UI
      // ===========================
      function createDeck() {
        const base = imageList.slice(0, upTo).map((src, idx) => ({ id: idx, src }));
        const doubled = [...base, ...base].map((c, k) => ({ ...c, uid: `${c.id}-${k}` }));
        return shuffle(doubled);
      }

      function renderGrid() {
        grid.innerHTML = '';
        state.deck.forEach(card => {
          const cell = document.createElement('div');
          cell.className = 'card';
          cell.role = 'gridcell';

          const btn = document.createElement('button');
          btn.type = 'button';
          btn.setAttribute('aria-label', 'Virar carta');
          btn.dataset.id = card.id;
          btn.dataset.uid = card.uid;

          const inner = document.createElement('div'); inner.className = 'inner';

          const front = document.createElement('div'); front.className = 'face front';
          const img = document.createElement('img');
          img.alt = 'Foto do casal'; img.loading = 'lazy'; img.src = card.src;
          const skeleton = document.createElement('div'); skeleton.className = 'skeleton';
          img.addEventListener('load', () => { img.classList.add('loaded'); skeleton.remove(); }, { once: true });
          front.appendChild(skeleton); front.appendChild(img);

          const back = document.createElement('div'); back.className = 'face back';
          const q = document.createElement('div'); q.className = 'qmark'; q.textContent = '?';
          back.appendChild(q);

          inner.appendChild(front); inner.appendChild(back);
          btn.appendChild(inner); cell.appendChild(btn); grid.appendChild(cell);

          btn.addEventListener('click', () => onFlip(btn, cell), { passive: true });
        });
      }

      function resetState() {
        stopTimer();
        state.firstCard = null;
        state.secondCard = null;
        state.lockBoard = false;
        state.matchedPairs = 0;
        setMoves(0);
        timeA.textContent = '00:00';
      }

      async function setup() {
        await preloadAll();
        resetState();
        state.deck = createDeck();
        renderGrid();
        startTimer();
      }

      // ===========================
      // LÃ“GICA DE JOGO
      // ===========================
      function onFlip(btn, cell) {
        if (state.lockBoard) return;
        const alreadyFlipped = cell.classList.contains('flipped');
        if (alreadyFlipped) return;

        cell.classList.add('flipped');
        if (!state.firstCard) {
          state.firstCard = { btn, cell, id: btn.dataset.id };
          vibrate(10);
          return;
        }
        state.secondCard = { btn, cell, id: btn.dataset.id };
        state.lockBoard = true;
        setMoves(state.moves + 1);
        window.requestAnimationFrame(() => checkMatch());
      }

      function checkMatch() {
        const isMatch = state.firstCard.id === state.secondCard.id;
        if (isMatch) { handleMatch(); } else { handleMismatch(); }
      }

      function handleMatch() {
        speak('Par encontrado!');
        vibrate([10, 40, 10]);
        state.firstCard.btn.disabled = true;
        state.secondCard.btn.disabled = true;
        state.firstCard.cell.style.outline = '2px solid rgba(74,222,128,.65)';
        state.secondCard.cell.style.outline = '2px solid rgba(74,222,128,.65)';

        state.matchedPairs++;
        state.firstCard = null; state.secondCard = null; state.lockBoard = false;

        if (state.matchedPairs === upTo) {
          stopTimer();
          triggerRevealSequence();
        }
      }

      function handleMismatch() {
        speak('Tente novamente');
        vibrate([40, 80]);
        const a = state.firstCard.cell, b = state.secondCard.cell;
        a.animate([{ transform: 'translateX(0)' }, { transform: 'translateX(-4px)' }, { transform: 'translateX(0)' }], { duration: 180 });
        b.animate([{ transform: 'translateX(0)' }, { transform: 'translateX(4px)' }, { transform: 'translateX(0)' }], { duration: 180 });
        setTimeout(() => {
          a.classList.remove('flipped');
          b.classList.remove('flipped');
          state.firstCard = null; state.secondCard = null; state.lockBoard = false;
        }, 420);
      }

      // ===========================
      // SUSPENSE + REVELAÃ‡ÃƒO
      // ===========================
      function triggerRevealSequence() {
        showSuspense(5).then(() => { triggerReveal(); });
      }

      function showSuspense(seconds = 5) {
        return new Promise((resolve) => {
          let remaining = seconds;
          countdownEl.textContent = remaining;
          suspenseLayer.classList.add('show');

          const conf = setInterval(() => {
            fire({ particleCount: 26, spread: 60, angle: 60, origin: { x: 0, y: 0.4 }, scalar: 1 });
            fire({ particleCount: 26, spread: 60, angle: 120, origin: { x: 1, y: 0.4 }, scalar: 1 });
          }, 220);

          const timer = setInterval(() => {
            remaining--;
            countdownEl.textContent = remaining;
            if (remaining <= 0) {
              clearInterval(timer);
              clearInterval(conf);
              suspenseLayer.classList.remove('show');
              resolve();
            }
          }, 1000);
        });
      }

      function triggerReveal() {
        const gender = GAME_CONFIG.revealGender === 'boy' ? 'boy' : 'girl';
        const themeColor = gender === 'girl' ? GAME_CONFIG.girlColor : GAME_CONFIG.boyColor;
        const name = gender === 'girl' ? 'Seja bem vinda, TÃ¡lia!!ðŸŽ€' : 'Seja bem vindo, ROMEU!!ðŸ’™';
        const title = gender === 'girl' ? 'Ã‰ MENINA!' : 'Ã‰ MENINO!';

        // Muda fundo + reduz foco do board
        document.body.style.background = themeColor;
        document.body.classList.add('reveal-mode');

        // Preenche overlay (sem imagem)
        revealTitle.textContent = title;
        babyName.textContent = name;
        revealText.textContent = REVEAL_MESSAGE;

        overlay.classList.add('show');

        // Confetes abundantes por ~5s
        celebrationConfetti(5200, themeColor);
      }

      // ===========================
      // ANIMAÃ‡Ã•ES DE CONFETE
      // ===========================
      function celebrationConfetti(durationMs = 10000, themeColor = "#ffffff") {
        const colors = [themeColor, "#ffffff", "#9b5de5", "#00bbf9"];
        const end = Date.now() + durationMs;

        (function frame() {
          fire({
            particleCount: 10,
            startVelocity: 35,
            spread: 360,
            origin: { x: Math.random(), y: Math.random() * 0.4 },
            colors, scalar: 1
          });
          if (Date.now() < end) { requestAnimationFrame(frame); }
        })();

        const burst = setInterval(() => {
          fire({ particleCount: 34, angle: 60, spread: 70, origin: { x: 0, y: 0.4 }, colors });
          fire({ particleCount: 34, angle: 120, spread: 70, origin: { x: 1, y: 0.4 }, colors });
          if (Date.now() > end) clearInterval(burst);
        }, 240);
      }

      // ===========================
      // REINICIAR
      // ===========================
      function clearOverlay() { overlay.classList.remove('show'); }
      function restart() {
        clearOverlay();
        document.body.classList.remove('reveal-mode');
        document.body.style.background = '';
        setup();
      }

      restartTop.addEventListener('click', restart);
      playAgain.addEventListener('click', restart);

      // ===========================
      // INICIALIZA
      // ===========================
      setup();
    });
  </script>
</body>

</html>